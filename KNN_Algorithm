def l2distance(X,Z=None):
    # function D=l2distance(X,Z)
    #
    # Computes the Euclidean distance matrix.
    # Syntax:
    # D=l2distance(X,Z)
    # Input:
    # X: nxd data matrix with n vectors (rows) of dimensionality d
    # Z: mxd data matrix with m vectors (rows) of dimensionality d
    #
    # Output:
    # Matrix D of size nxm
    # D(i,j) is the Euclidean distance of X(i,:) and Z(j,:)
    #
    # call with only one input:
    # l2distance(X)=l2distance(X,X)
    #

    if Z is None:
        Z=X;

    n,d1=X.shape
    m,d2=Z.shape
    assert (d1==d2), "Dimensions of input vectors must match!"
    
    # Find Gram matrix of input matrices, i.e. inner product
    G = np.dot(X,Z.T)
    
    # Sum square matrix entries
    S = np.sum(X**2, axis=1)[:, np.newaxis]
    R = np.sum(Z**2, axis=1)
    
    # Compute Euclidian distance between matrices
    Dsq = S + R - 2*G
    Dsq=np.absolute(Dsq)
    D = np.sqrt(Dsq)
    
    return D
    
def findknn(xTr,xTe,k):
    """
    function [indices,dists]=findknn(xTr,xTe,k);
    
    Finds the k nearest neighbors of xTe in xTr.
    
    Input:
    xTr = nxd input matrix with n row-vectors of dimensionality d
    xTe = mxd input matrix with m row-vectors of dimensionality d
    k = number of nearest neighbors to be found
    
    Output:
    indices = kxm matrix, where indices(i,j) is the i^th nearest neighbor of xTe(j,:)
    dists = Euclidean distances to the respective nearest neighbors
    """

    # Find Euclidian distances from each test vector to each training point
    edm = l2distance(xTr,xTe)

    # Sort distances and respective indices
    edm_sorted = np.sort(edm,axis=0)
    edm_index = np.argsort(edm,axis=0)
    
    # Record distance and index of each to k nearest neighbors    
    indices = edm_index[:k,:].astype(int)
    dists = edm_sorted[:k,:]

    return indices, dists
